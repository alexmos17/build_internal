Index: content/browser/renderer_host/media/video_capture_manager.cc
diff --git a/content/browser/renderer_host/media/video_capture_manager.cc b/content/browser/renderer_host/media/video_capture_manager.cc
index 00fa52e43eb0e366848c675ecf7bd44a6559dfe9..4784134613e928bd3bef59df78b6288d19d2920e 100644
--- content/browser/renderer_host/media/video_capture_manager.cc
+++ content/browser/renderer_host/media/video_capture_manager.cc
@@ -19,8 +19,10 @@
 #include "content/public/common/content_switches.h"
 #include "content/public/common/desktop_media_id.h"
 #include "content/public/common/media_stream_request.h"
+#include "media/base/media_switches.h"
 #include "media/base/scoped_histogram_timer.h"
 #include "media/video/capture/fake_video_capture_device.h"
+#include "media/video/capture/file_video_capture_device.h"
 #include "media/video/capture/video_capture_device.h"
 
 #if defined(ENABLE_SCREEN_CAPTURE)
@@ -45,7 +47,7 @@ VideoCaptureManager::DeviceEntry::~DeviceEntry() {}
 VideoCaptureManager::VideoCaptureManager()
     : listener_(NULL),
       new_capture_session_id_(1),
-      use_fake_device_(false) {
+      artificial_device_source_for_testing_ (DISABLED) {
 }
 
 VideoCaptureManager::~VideoCaptureManager() {
@@ -131,7 +133,12 @@ void VideoCaptureManager::Close(int capture_session_id) {
 }
 
 void VideoCaptureManager::UseFakeDevice() {
-  use_fake_device_ = true;
+  if (CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kUseFileForFakeVideoCapture)) {
+    artificial_device_source_for_testing_ = Y4M_FILE;
+  } else {
+    artificial_device_source_for_testing_ = TEST_PATTERN;
+  }
 }
 
 void VideoCaptureManager::DoStartDeviceOnDeviceThread(
@@ -150,9 +157,20 @@ void VideoCaptureManager::DoStartDeviceOnDeviceThread(
       media::VideoCaptureDevice::Name* found =
           video_capture_devices_.FindById(entry->id);
       if (found) {
-        video_capture_device.reset(use_fake_device_ ?
-            media::FakeVideoCaptureDevice::Create(*found) :
-            media::VideoCaptureDevice::Create(*found));
+        switch (artificial_device_source_for_testing_) {
+          case DISABLED:
+            video_capture_device.reset(
+                media::VideoCaptureDevice::Create(*found));
+            break;
+          case TEST_PATTERN:
+            video_capture_device.reset(
+                media::FakeVideoCaptureDevice::Create(*found));
+            break;
+          case Y4M_FILE:
+            video_capture_device.reset(
+                media::FileVideoCaptureDevice::Create(*found));
+            break;
+        }
       }
       break;
     }
@@ -320,10 +338,16 @@ VideoCaptureManager::GetAvailableDevicesOnDeviceThread(
       // Cache the latest enumeration of video capture devices.
       // We'll refer to this list again in OnOpen to avoid having to
       // enumerate the devices again.
-      if (!use_fake_device_) {
-        media::VideoCaptureDevice::GetDeviceNames(&result);
-      } else {
-        media::FakeVideoCaptureDevice::GetDeviceNames(&result);
+      switch (artificial_device_source_for_testing_) {
+        case DISABLED:
+          media::VideoCaptureDevice::GetDeviceNames(&result);
+          break;
+        case TEST_PATTERN:
+          media::FakeVideoCaptureDevice::GetDeviceNames(&result);
+          break;
+        case Y4M_FILE:
+          media::FileVideoCaptureDevice::GetDeviceNames(&result);
+          break;
       }
 
       // TODO(nick): The correctness of device start depends on this cache being
Index: content/browser/renderer_host/media/video_capture_manager.h
diff --git a/content/browser/renderer_host/media/video_capture_manager.h b/content/browser/renderer_host/media/video_capture_manager.h
index 67dbb753735a817cb4a2d998c5eb3b916bad53c9..82c61537ddf4ae17c735ca8c04dc14b4c41ecf13 100644
--- content/browser/renderer_host/media/video_capture_manager.h
+++ content/browser/renderer_host/media/video_capture_manager.h
@@ -168,9 +168,15 @@ class CONTENT_EXPORT VideoCaptureManager : public MediaStreamProvider {
   typedef std::set<DeviceEntry*> DeviceEntries;
   DeviceEntries devices_;
 
-  // Set to true if using fake video capture devices for testing, false by
-  // default. This is only used for the MEDIA_DEVICE_VIDEO_CAPTURE device type.
-  bool use_fake_device_;
+  // For unit testing and for performance/quality tests, a test device can be
+  // used instead of a real one. The device can be a simple fake device (a
+  // rolling pacman), or a file that is played in a loop continuously. This only
+  // applies to the MEDIA_DEVICE_VIDEO_CAPTURE device type.
+  enum {
+    DISABLED,
+    TEST_PATTERN,
+    Y4M_FILE
+  } artificial_device_source_for_testing_;
 
   // We cache the enumerated video capture devices in
   // GetAvailableDevicesOnDeviceThread() and then later look up the requested ID
